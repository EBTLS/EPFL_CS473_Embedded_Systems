#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "system.h"
#include "io.h"

#include "i2c/i2c.h"
#include "cmos_sensor_output_generator/cmos_sensor_output_generator.h"
#include "cmos_sensor_output_generator/cmos_sensor_output_generator_regs.h"

//I2C Macros
#define I2C_FREQ                (50000000) /* Clock frequency driving the i2c core: 50 MHz in this example (ADAPT TO YOUR DESIGN) */
#define TRDB_D5M_I2C_ADDRESS    (0xba)
#define TRDB_D5M_0_I2C_0_BASE   (0x10000808)   /* i2c base address from system.h (ADAPT TO YOUR DESIGN) */

// HPS Macros
#define ONE_MB 					(1024 * 1024)

//CMOS SENSOR Macros
#define CMOS_SENSOR_OUTPUT_GENERATOR_0_BASE       (0x10000820) /* cmos_sensor_output_generator base address from system.h (ADAPT TO YOUR DESIGN) */
#define CMOS_SENSOR_OUTPUT_GENERATOR_0_PIX_DEPTH  (12)     /* cmos_sensor_output_generator pix depth from system.h (ADAPT TO YOUR DESIGN) */
#define CMOS_SENSOR_OUTPUT_GENERATOR_0_MAX_WIDTH  (1920)    /* cmos_sensor_output_generator max width from system.h (ADAPT TO YOUR DESIGN) */
#define CMOS_SENSOR_OUTPUT_GENERATOR_0_MAX_HEIGHT (1080)    /* cmos_sensor_output_generator max height from system.h (ADAPT TO YOUR DESIGN) */

// camera top macros
#define CAMERA_TOP_START_REG (0x00)
#define CAMERA_TOP_DMA_LEN_REG (0x01)
#define CAMERA_TOP_DMA_DEST_ADDRESS_REG (0x02)
#define CAMERA_TOP_CLEAR_TASK_FLAG_REG (0x03)
#define CAMERA_TOP_TASK_FINISHED_FLAG_REG (0x04)
#define CAMERA_TOP_TRIGGER_REG (0x05)


/*
 * Functions for dealing with camera configuration
 */
bool trdb_d5m_write(i2c_dev *i2c, uint8_t register_offset, uint16_t data) {
    uint8_t byte_data[2] = {(data >> 8) & 0xff, data & 0xff};

    int success = i2c_write_array(i2c, TRDB_D5M_I2C_ADDRESS, register_offset, byte_data, sizeof(byte_data));

    if (success != I2C_SUCCESS) {
        return false;
    } else {
        return true;
    }
}

bool trdb_d5m_read(i2c_dev *i2c, uint8_t register_offset, uint16_t *data) {
    uint8_t byte_data[2] = {0, 0};

    int success = i2c_read_array(i2c, TRDB_D5M_I2C_ADDRESS, register_offset, byte_data, sizeof(byte_data));

    if (success != I2C_SUCCESS) {
        return false;
    } else {
        *data = ((uint16_t) byte_data[0] << 8) + byte_data[1];
        return true;
    }
}


/*
 * Function for configuring cmos sensor
 */
void configure_cmos_sensor(){
    cmos_sensor_output_generator_dev cmos_sensor_output_generator = cmos_sensor_output_generator_inst(CMOS_SENSOR_OUTPUT_GENERATOR_0_BASE,
                                                                                                      CMOS_SENSOR_OUTPUT_GENERATOR_0_PIX_DEPTH,
                                                                                                      CMOS_SENSOR_OUTPUT_GENERATOR_0_MAX_WIDTH,
                                                                                                      CMOS_SENSOR_OUTPUT_GENERATOR_0_MAX_HEIGHT);
    cmos_sensor_output_generator_init(&cmos_sensor_output_generator);
    cmos_sensor_output_generator_stop(&cmos_sensor_output_generator);
    int cmos_status=IORD_32DIRECT(CMOS_SENSOR_OUTPUT_GENERATOR_0_BASE, 0x1C);
    printf("cmos status %d \n", cmos_status);
    cmos_sensor_output_generator_configure(&cmos_sensor_output_generator,
                                           640,
                                           480,
                                           CMOS_SENSOR_OUTPUT_GENERATOR_CONFIG_FRAME_FRAME_BLANK_MIN,
                                           CMOS_SENSOR_OUTPUT_GENERATOR_CONFIG_FRAME_LINE_BLANK_MIN,
                                           CMOS_SENSOR_OUTPUT_GENERATOR_CONFIG_LINE_LINE_BLANK_MIN,
                                           CMOS_SENSOR_OUTPUT_GENERATOR_CONFIG_LINE_FRAME_BLANK_MIN);

    cmos_sensor_output_generator_start(&cmos_sensor_output_generator);
    cmos_status=IORD_32DIRECT(CMOS_SENSOR_OUTPUT_GENERATOR_0_BASE, 0x1C);
    printf("cmos status %d \n", cmos_status);
}

/*
 * Function for initializing the camera
 */
bool test_pattern_setting(i2c_dev *i2c){
	 bool success=true;
	//test green
	 uint16_t readdata = 4095;
	 success &= trdb_d5m_write(&i2c, 0xA1, readdata);
		if (success){
			printf("1 success\n");
		}else{
			printf("1 failed \n");
		}


	 //test blue
	readdata=0;
	success &= trdb_d5m_write(&i2c, 0xA3, readdata);
	if (success){
		printf("2 success\n");
	}else{
		printf("2 failed \n");
	}

	//test red
	readdata=0;
	success &= trdb_d5m_write(&i2c, 0xA2, readdata);
	if (success){
		printf("3 success\n");
	}else{
		printf("4 failed \n");
	}

	success &=trdb_d5m_write(&i2c, 0xA0, 0x01);
	if (success){
		printf("4 success\n");
	}else{
		printf("4 failed \n");
	}

	return success;
}


bool camera_initialization(i2c_dev *i2c){
    bool success = true;
    // column size
	success &= trdb_d5m_write(i2c, 0x04, 2559);
	if (success){
		printf("1 success\n");
	}else{
		printf("1 failed \n");
	}
	// row size
	success &= trdb_d5m_write(i2c, 0x03, 1919);
	if (success){
		printf("2 success\n");
	}else{
		printf("2 failed \n");
	}
	// row bin and row skip
	uint16_t readdata=0;
	success &=trdb_d5m_read(i2c,0x22,&readdata);
	readdata |=0x0033;
	success &= trdb_d5m_write(i2c,0x22, readdata);
	if (success){
		printf("3 success\n");
	}else{
		printf("3 failed \n");
	}
	// column bin and column skip
	readdata=0;
	success &=trdb_d5m_read(i2c,0x23,&readdata);
	readdata |=0x0033;
	success &= trdb_d5m_write(i2c, 0x23, readdata);
	if (success){
		printf("4 success\n");
	}else{
		printf("4 failed \n");
	}

	//pixel clock control
	readdata=0;
	success &=trdb_d5m_read(i2c,0x0A,&readdata);
	readdata &=0x0000;
	success &= trdb_d5m_write(i2c, 0x0A, readdata);
	if (success){
		printf("5 success\n");
	}else{
		printf("5 failed \n");
	}

	//set snapshot
	success &=trdb_d5m_read(i2c,0x1E,&readdata);
	readdata|=0x0100;
	success &= trdb_d5m_write(i2c,0x1E,readdata);
	if (success){
		printf("6 success\n");
	}else{
		printf("6 failed \n");
	}

//	success&=test_pattern_setting(i2c);
//	if (success){
//		printf("7 success\n");
//	}else{
//		printf("7 failed \n");
//	}

	//trigger pin hold
	IOWR_32DIRECT(CAMERA_TOP_0_BASE, CAMERA_TOP_TRIGGER_REG*4, 0x00000001);

	usleep(2000 * 1000);
	return success;
}

/*
 * Function for initializing the camera controller
 */
void camera_top_initialization(){
	// Camera Controller Initialization

    IOWR_32DIRECT(CAMERA_TOP_0_BASE, CAMERA_TOP_DMA_LEN_REG*4, 76800*10000);
    IOWR_32DIRECT(CAMERA_TOP_0_BASE, CAMERA_TOP_DMA_DEST_ADDRESS_REG*4, 0x00000000);
    IOWR_32DIRECT(CAMERA_TOP_0_BASE, CAMERA_TOP_CLEAR_TASK_FLAG_REG*4, 0x00000000);
    IOWR_32DIRECT(CAMERA_TOP_0_BASE, CAMERA_TOP_START_REG*4, 0x00000011);

}

bool trigger_camera(i2c_dev *i2c){
	bool success=true;
	success &= trdb_d5m_write(i2c, 0x0B, 0x0004);
	return success;
}

bool stop_trigger_camera(i2c_dev *i2c){
	bool success=true;
	success &= trdb_d5m_write(i2c, 0x0B, 0x0000);
	return success;
}

/**
 * transform data from memory to file
 */
bool StoreToFile(){

	  printf("Start 1!\n");
	  char* filename = "/mnt/host/imagex.ppm";
	  printf("Start 2!\n");
	  FILE *fp = fopen(filename, "wb");
	  if (!fp){
	  	printf("Error: could not open \"%s\" for reading\n", filename);
	  	return false;
	  }
	  printf("Start 3!\n");
	  // Header
	  (void) fprintf(fp, "P6\n%d %d\n255\n", 320, 240);

	  // Body
	  for(uint32_t row = 0; row < 240; row++) {
	    for(uint32_t col = 0; col < 320; col++) {
	      uint32_t addr=HPS_0_BRIDGES_BASE+(row*320+col)*sizeof(uint32_t);
	      uint32_t pixelVal=IORD_32DIRECT(addr,0);

	      uint8_t colors[3];
	      //red
	      colors[0] = (pixelVal >> 16) & 0x00ff;
	      //green
	      colors[1] = (pixelVal >> 8) & 0x00ff;
	      //blue
	      colors[2] = (pixelVal) & 0x00ff;

	      (void) fwrite(colors, sizeof(uint8_t), 3, fp);
	    }
	  }

	  (void) fclose(fp);
	  printf("Done!\n");

	uint32_t i=0;
	for (i=0; i<76800;++i){
		if ((i<1000) || (i>76000)){
			uint32_t addr=HPS_0_BRIDGES_BASE+i*sizeof(uint32_t);
			uint32_t readdata=IORD_32DIRECT(addr,0);
			printf("pixel: %d value: %lu ",i,readdata);
		}
	}

	return true;
}

int main(void) {


//    i2c_dev i2c = i2c_inst((void *) TRDB_D5M_0_I2C_0_BASE);
//    i2c_init(&i2c, I2C_FREQ);
//	bool success=camera_initialization(&i2c);
//	if (success){
//		printf("camera initialization success\n");
//	}else{
//		printf("camera initialization failed \n");
//	}

	camera_top_initialization();
	uint32_t base_address=IORD_32DIRECT(CAMERA_TOP_0_BASE,0x02*4);
	printf("address %lu \n", base_address);
	uint32_t length_setting=IORD_32DIRECT(CAMERA_TOP_0_BASE,0x01*4);
	printf("length setting %lu \n", length_setting);
	uint32_t status=IORD_32DIRECT(CAMERA_TOP_0_BASE,0x00*4);
	printf("status %lu \n", status);
	configure_cmos_sensor();
	uint32_t task_finished=0;
//	success=true;
//	success &=trigger_camera(&i2c);
//	if (success){
//		printf("camera trigger success\n");
//	}else{
//		printf("camera trigger failed \n");
//	}

	while (task_finished==0){
		task_finished=IORD_32DIRECT(CAMERA_TOP_0_BASE,CAMERA_TOP_TASK_FINISHED_FLAG_REG*4);
	}
	printf("dma finished! \n");
	bool success=true;
//	success&=stop_trigger_camera(&i2c);

	success&=StoreToFile();
	if (success){
		printf("store to file success \n");
	}else{
		printf("store to file failed \n");
	}


}
